# v2.12.0 Integration Guide: Self-Evolving Playbook System

**Version**: v2.12.0
**Released**: 2026-02-12
**Status**: Production Ready

> **Start here instead?** If you're new to v2.12.0, read the [Quick Start Guide](v2.12.0-quick-start.md) first (5-30 minutes). This guide covers deeper architecture and integration details.

---

## Overview

v2.12.0 represents the third phase of the self-evolving playbook system, building on a foundation of context minimization and session protection to create a complete ecosystem for sustainable development workflow.

The system consists of three interlocking capabilities:

1. **Context Minimization** (Phase 1) — Efficient context management with explicit safety markers
2. **Session Boundary Protection** (Phase 2) — Verified context recovery at session transitions
3. **Data-Driven Insights** (Phase 3) — Git history analysis for evolution planning

Together, these capabilities enable:
- Efficient sessions with minimal context waste
- Safe context transitions with no silent guideline loss
- Data-informed quarterly evolution cycles
- Ad-hoc investigation and area health analysis

---

## The Three Phases

### Phase 1: Context Minimization

**Problem it solves**: Claude Code sessions have limited context windows. Keeping essential guidelines visible while minimizing bloat requires careful architecture.

**What it introduces**:
- **BEACONs**: 9 critical guidelines (6 global + 3 project) explicitly marked with dual presence
  - Summary in context files (quick reference)
  - Full detail in playbooks (comprehensive understanding)
- **Four-layer context architecture**:
  - Layer 1: Global (`~/.claude/CLAUDE.md`) — Universal principles (190 lines)
  - Layer 2: Project (`.claude/CLAUDE.md`) — Project structure (178 lines)
  - Layer 3: Memory (`memory/MEMORY.md`) — Learned patterns (336 lines)
  - Layer 4: Session (`todos/1-working-context.md`, `pause-notes.md`) — Current state
- **Session state preservation**:
  - Durable working-context (survives sessions, updated on releases)
  - Ephemeral pause-notes (session-specific, appended on pause, read on resume)

**How to use it**:
- BEACONs are always active, preventing silent guideline loss
- Four layers load on session start automatically
- Context is compressed to fit token budget
- Memory serves as persistent pattern library

**Reference**: `/pb-preamble`, `/pb-design-rules` (global BEACONs)

---

### Phase 2: Session Boundary Protection

**Problem it solves**: When you pause work (end of day, context switch), your session ends and context unloads. When you resume, you must reload. Without explicit verification, guidelines can become invisible.

**What it introduces**:
- **Enhanced /pb-pause** with Step 6.5: Verify Active BEACONs
  - Displays all 9 BEACONs before pausing
  - Creates checkpoint in pause-notes documenting state
  - Prevents pausing if critical BEACONs missing
  - Guides recovery if BEACON lost

- **Enhanced /pb-resume** with Steps 3.5-3.6: Load Context Layers & Verify BEACONs
  - Loads all 4 layers in sequence with visible progress
  - Verifies all 9 BEACONs active after loading
  - Provides guidance for missing BEACONs
  - Recovers from compaction safely

**How to use it**:
```bash
# Before stopping work
/pb-pause
  # Displays all 9 BEACONs
  # Creates checkpoint in pause-notes
  # Prevents silent guideline loss

[Time passes, session ends, context unloaded]

# After resuming
/pb-resume
  # Loads 4 context layers
  # Verifies all 9 BEACONs
  # Recovers session state from pause-notes
  # Ready to continue work
```

**Real-world example: Friday 5pm to Monday 9am**

Friday 5pm:
```
Developer runs: /pb-pause
System displays:
  Global BEACONs (6): ✓ Preamble, Design Rules, Code Quality, Non-Negotiables, Quality Bar, Model Selection
  Project BEACONs (3): ✓ Project Guardrails, Audit Conventions, Key Patterns

Pause-notes records:
  - Last commit: "feat: add password validation"
  - Next steps: 1. Email verification endpoint, 2. Integration tests, 3. API docs
  - BEACONs verified: All 9 active ✓

Developer closes laptop. Context unloaded.
```

Monday 9am:
```
Developer runs: /pb-resume
System displays:
  === RESUMING: Loading Context Layers ===
  Layer 1: Global (~/.claude/CLAUDE.md) ✓ (6 BEACONs)
  Layer 2: Project (.claude/CLAUDE.md) ✓ (3 BEACONs)
  Layer 3: Memory (memory/MEMORY.md) ✓
  Layer 4: Session (todos/) ✓

  === BEACON VERIFICATION ===
  All 9 BEACONs verified and active ✓

Recovered from pause-notes:
  - Branch: feature/user-auth
  - Next steps: Email verification endpoint (from pause-notes)
  - Last commit: "feat: add password validation"

Developer continues work with full context and verified guidelines.
```

**Reference**: `docs/beacon-verification-at-boundaries.md`, `/pb-pause`, `/pb-resume`

---

### Phase 3: Git History Signal Analysis

**Problem it solves**: Planning improvements requires understanding what's actually used and what causes pain. Manual analysis is slow. Automated insights enable data-driven decisions.

**What it introduces**:
- **/pb-git-signals** command for analyzing git history
  - Extracts adoption metrics (what's touched frequently)
  - Analyzes churn patterns (high-change areas)
  - Detects pain points (reverts, bug fixes, hotfixes)
  - Generates JSON for tooling + markdown for humans

**How to use it**:

Weekly trends:
```bash
python scripts/git-signals.py --since "1 week ago"
cat todos/git-signals/latest/signals-summary.md
# See what was hot this week
```

Before quarterly planning:
```bash
python scripts/git-signals.py
# Review pain_score_by_file
# Use to prioritize /pb-evolve work
```

Ad-hoc investigation:
```bash
python scripts/git-signals.py
# Identify problem areas
# Understand refactoring targets
```

**Three signal types**:

1. **Adoption Signals** — What gets used
   - High adoption + Low churn = Stable, trusted
   - High adoption + High churn = Active, evolving
   - Low adoption + Low churn = Stale, candidates for removal
   - Low adoption + High churn = Experimental or problematic

2. **Churn Signals** — What changes frequently
   - High line changes + High commits = Volatile area
   - High line changes + Low commits = Large-scale changes
   - Low line changes + High commits = Many small tweaks

3. **Pain Point Signals** — Where problems occur
   - Reverts = Mistakes that needed undoing (clear problems)
   - Bug fixes = Issues in commit subjects
   - Hotfixes = Urgent problems requiring immediate fixes
   - Pain score = Composite metric identifying troubled areas

**Real example from playbook**:
```
Adoption: pb-guide 47 touches (most active)
Churn: commands/core/pb-guide.md 5000+ line changes (high activity)
Pain: pb-guide pain_score 8 (multiple fixes/reverts) → Consider refactoring

Adoption: pb-pause/pb-resume v1.2.0 with built-in context hygiene
Note: Reference implementations (pb-pause-enhanced, pb-resume-enhanced) removed — logic merged into actual commands

Adoption: pb-legacy 1 touch (stale)
Churn: None in 6 months
Pain: None (abandoned)
→ Candidate for deprecation or removal
```

**Reference**: `/pb-git-signals`, `commands/core/pb-git-signals.md`

---

## How They Work Together

```
SESSION LIFECYCLE WITH v2.12.0

START WORK
    ↓
LOAD CONTEXT (Phase 1)
    • Layer 1: Global principles
    • Layer 2: Project structure
    • Layer 3: Learned patterns
    • Layer 4: Session state
    ↓
VERIFY BEACONS (Phase 2 implicit)
    • All 9 guidelines active
    • No silent guideline loss
    ↓
WORK (repeat as needed)
    • Efficient context management
    • Clear guidelines always present
    ↓
PAUSE WORK → VERIFY BEACONS (Phase 2 explicit)
    • Step 6.5: Confirm all 9 BEACONs
    • Document state in pause-notes
    • Create checkpoint
    ↓
[TIME PASSES, CONTEXT UNLOADED]
    ↓
RESUME WORK → LOAD & VERIFY (Phase 2 explicit)
    • Step 3.5: Load 4 context layers
    • Step 3.6: Verify all 9 BEACONs
    • Recover session state
    ↓
WORK (continue from pause-notes)
    ↓
QUARTERLY PLANNING (Phase 3)
    • Run: python scripts/git-signals.py
    • Review: adoption metrics, churn analysis, pain points
    • Input: pain_score_by_file → /pb-evolve priorities
    ↓
EVOLVE SYSTEM (quarterly cycle)
    • /pb-evolve uses signals for data-driven decisions
    • Update playbooks for Q2 (May)
    • Back to START WORK

```

---

## Decision Tree: When to Use Each Phase

### Phase 1: Context Minimization
**Automatic/always active**
- Used on every session start
- BEACONs loaded into main context
- Four-layer architecture manages what's visible
- No explicit action needed (transparent)

### Phase 2: Session Boundary Protection
**When pausing/resuming work**

Use `/pb-pause` when:
- Ending work for the day (hours-long break)
- Switching to different project (context switch)
- Taking extended time off (vacation, leave)
- End of development phase (milestone reached)
- **Why**: Ensures guidelines are verified and documented before context loss

Use `/pb-resume` when:
- Starting work after break (hours, days, weeks)
- Returning from context switch
- After session compaction (context reloaded)
- **Why**: Ensures all guidelines reloaded before continuing

**Rule**: Every pause should have a corresponding resume

### Phase 3: Git Signals
**Before planning or when investigating**

Use `/pb-git-signals` when:
- **Weekly**: "What was hot this week?" — Track trends
- **Before quarterly planning**: Inform `/pb-evolve` decisions
- **After incidents**: Investigate pain patterns
- **Before refactoring**: Identify high-churn areas
- **Ad-hoc investigation**: Understand area health
- **Onboarding**: Show new contributors what's active

**Frequency**:
- Weekly: Quick trends (--since "1 week ago")
- Monthly: Deeper trends (--since "1 month ago")
- Quarterly: Strategic input (--since "3 months ago")
- Annually: Historical patterns (--since "1 year ago")

---

## Real-World Workflow Example

**Scenario**: Developer working on user authentication feature over a week

**Monday morning**:
```
1. /pb-resume (from previous session)
   - Loads 4 context layers
   - Verifies all 9 BEACONs active
   - Recovers last week's state: feature branch feature/user-auth

2. Review pause-notes from last Friday:
   - Last commit: "feat: add password validation"
   - Next: Email verification, integration tests, docs

3. Continue work on email verification endpoint
```

**Throughout the week** (Monday-Thursday):
```
Each day:
  /pb-cycle repeatedly
    • Code → Self-review → Refine
    • Verify BEACONs still active
    • Update trackers

Daily work respects Phase 1 (efficient context) and Phase 2 (guidelines explicit)
```

**Friday evening**:
```
1. Complete current task: "feat: add email verification endpoint"
2. Run final tests: make lint && make test
3. /pb-pause
   - Step 6.5: Verify BEACONs (all 9 present ✓)
   - Document state:
     • Last commit: feat: add email verification endpoint
     • Next: Integration tests + API docs
     • BEACONs: All 9 verified and documented

4. Developer leaves for weekend
```

**Monday morning next week**:
```
1. /pb-resume
   - Loads 4 context layers: Global → Project → Memory → Session
   - Verifies BEACONs: All 9 active ✓
   - Recovers state: feature/user-auth, next: integration tests

2. Continue with integration tests (from documented next steps)
```

**Before Q2 planning (May)**:
```
1. /pb-git-signals --since "3 months ago"
   - Adoption: pb-standards and pb-testing heavily touched (active focus)
   - Churn: commands/development/ high churn (active development)
   - Pain: pb-testing pain_score 6 (multiple bug fixes in tests)

2. /pb-evolve uses these signals:
   - High pain areas get prioritized for Q2
   - Low adoption areas get review for deprecation
   - Churn areas inform which patterns need stability work

3. Plans Q2 improvements based on data
```

---

## FAQ: Integration

**Q: Do I need to use all three phases?**
A: Phase 1 (context minimization) is automatic and always active. Phases 2-3 are opt-in:
- Phase 2: Use /pb-pause and /pb-resume when dealing with extended breaks
- Phase 3: Use /pb-git-signals before planning or when investigating

**Q: What if I forget to run /pb-pause before pausing?**
A: Pause-notes won't be created and BEACONs won't be documented. On resume, you'll start fresh (all guidelines reloaded but no session state recovery). Not harmful, just less convenient.

**Q: Can I use git-signals without being a maintainer?**
A: Yes! The script works on any git repository. Use it on your own projects to understand activity patterns and pain areas.

**Q: What if BEACON verification fails on resume?**
A: Recovery options:
```bash
# Option 1: Refresh context
/pb-context

# Option 2: Refresh CLAUDE.md files
/pb-claude-project

# Option 3: Start fresh (context reloads on next session)
```

**Q: How does Phase 3 integrate with /pb-evolve?**
A: Before running /pb-evolve quarterly, run /pb-git-signals to get signals. Use pain_score_by_file to prioritize which areas to focus evolution effort on.

**Q: Is v2.12.0 backwards compatible?**
A: Yes. All new capabilities are opt-in. Existing workflows continue to work unchanged.

---

## Architecture Overview

```
v2.12.0 ARCHITECTURE

GLOBAL GUIDELINES (~/.claude/CLAUDE.md)
    │
    ├─ BEACON: Preamble
    ├─ BEACON: Design Rules
    ├─ BEACON: Code Quality
    ├─ BEACON: Non-Negotiables
    ├─ BEACON: Quality Bar
    └─ BEACON: Model Selection

PROJECT STRUCTURE (.claude/CLAUDE.md)
    │
    ├─ BEACON: Project Guardrails
    ├─ BEACON: Audit Conventions
    └─ BEACON: Key Patterns

LEARNED PATTERNS (memory/MEMORY.md)
    │
    └─ BEACON Quick Reference (all 9 BEACONs)

SESSION STATE (todos/)
    │
    ├─ working-context.md (durable, updated on releases)
    └─ pause-notes.md (ephemeral, for session handoff)

GIT HISTORY
    │
    ├─ Adoption Metrics (what's touched)
    ├─ Churn Analysis (what changes)
    └─ Pain Points (where problems are)

DATA FLOW
    ├─ On session start: Load all 4 layers, verify BEACONs
    ├─ On work: Efficient context with explicit guidelines
    ├─ On pause: Document state, verify BEACONs
    ├─ On resume: Reload layers, verify BEACONs, recover state
    └─ Quarterly: Analyze signals, inform evolution priorities
```

---

## Upgrade Guide: v2.11.0 to v2.12.0

### What's New
- Context minimization system with BEACON markers
- Session boundary verification (enhanced /pb-pause and /pb-resume)
- Git history signal analysis (/pb-git-signals command)

### Breaking Changes
None. All features are backwards compatible and opt-in.

### Migration Steps
1. Pull latest version (includes all three phases)
2. Optional: Start using /pb-pause and /pb-resume with BEACON verification
3. Optional: Try /pb-git-signals for weekly trends or quarterly planning
4. No urgent action required — existing workflow continues to work

### Recommended First Steps
1. Read this integration guide
2. Try /pb-git-signals on your repository
3. Use /pb-pause at end of workday (optional but recommended)
4. Use /pb-resume on workday start (optional but recommended)
5. Use git-signals output to inform next quarterly planning

---

## Related Documentation

### Complete Reference
- `/pb-preamble` — Collaboration philosophy (global BEACON)
- `/pb-design-rules` — Design principles (global BEACON)
- `/pb-standards` — Code quality standards
- `/pb-pause` — Pause work with BEACON verification
- `/pb-resume` — Resume work with BEACON loading
- `/pb-git-signals` — Git history analysis
- `/pb-evolve` — Quarterly evolution planning
- `docs/beacon-verification-at-boundaries.md` — BEACON system details

### Key Files
- `~/.claude/CLAUDE.md` — Global context (Layer 1)
- `.claude/CLAUDE.md` — Project context (Layer 2)
- `memory/MEMORY.md` — Persistent patterns (Layer 3)
- `todos/1-working-context.md` — Durable session state (Layer 4)
- `todos/pause-notes.md` — Ephemeral session state (Layer 4)

---

## Success Criteria for v2.12.0

✅ **Context Minimization**: 9 BEACONs with dual presence architecture
✅ **Session Verification**: Enhanced pause/resume with BEACON checks
✅ **Data-Driven Planning**: Git signal analysis for evolution
✅ **Integration**: All three phases work together seamlessly
✅ **Documentation**: Comprehensive guides and real-world examples
✅ **Backwards Compatible**: No breaking changes, all features opt-in
✅ **Production Ready**: Tested and verified for stable operation

---

**v2.12.0 represents a major step forward in creating a sustainable, efficient, and data-informed development workflow.**

*For issues or questions, refer to the specific phase documentation or the troubleshooting sections in each guide.*
